// Grover's algorithm for a single solution
// - Returns the only x for which f(x) = 1
//
// - More detailed description: https://www.scottaaronson.com/qclec/22.pdf


def grover[n:!â„•](f: const uint[n] !â†’ lifted ğ”¹):!â„•{ 
	nIterations:= round(Ï€ / 4 * sqrt(2^n));
	cand:=0:uint[n];
    for k in [0..n) {cand[k] := H(cand[k]);} 
	
	for k in [0..nIterations){
		if f(cand){
			phase(Ï€);
		}		
		// state ignoring normalization:   
    	// âˆ‘(vâ‰ w)|vâŸ© - |w*âŸ©
		cand:=groverDiffusion(cand);  
    	// âˆ‘(vâ‰ w)Î³â‚‹|vâŸ© + Î³â‚Š|w*âŸ©
	}
	return measure(cand) as !â„•;
}

/* EXAMPLE CALL */

def main() {
	f := Î»(x:uint[5])lifted:ğ”¹{return x==3;}; // creates an oracle which outputs one only when x=3
	x := grover(f); 
	assert(x==3); // verifies that grover finds the right solution

	return x;
}

// Grover Diffusion Operator

def groverDiffusion[n:!â„•](cand:uint[n])mfree: uint[n]{
	for k in [0..n) { cand[k] := H(cand[k]); }
	if cand!=0{ phase(Ï€); }
	for k in [0..n) { cand[k] := H(cand[k]); }
	return cand;
}


/* TEST */

// Random number generators

def uniformInt(range:!â„•){
    // returns x~{0,...range-1}
    n:=ceil(log(range)/log(2)) coerce !â„•;
    r:=range;
    while (r>range-1) {
        // rerolls r if it is greater than range
        r=0;
        for k in [0..n){
            // rolls each bit of r
            r+=2^k*rand();
        }   
    }
    return r;
}

def rand(){
    // quantum number generator
    return measure(H(false));
}



// This function defines a test for Grover
def test_grover() {
	def f(x:uint[3])lifted:ğ”¹{
    	return x==7;
	} // creates an oracle which outputs one only when x=3
	x := grover(f);
	// verifies that grover finds the right solution
	assert(x==7);

	return x;
}